/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "livre.h"

//déclarer liste de livre globale
livres lvr;

int *
init_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	//replire qlq livre

	livre lv1,lv2,lv3;

	lv1.num = 1;
	lv1.titre = "djabir";
	lv1.auteur = "djabir";
	lv1.editeur = "djabir";
	lv1.anneePub = "1998/04/01";
	lv1.nbrExmplr = 5;
	lv1.prix = 9.99;

	lv2.num = 2;
	lv2.titre = "omar";
	lv2.auteur = "omar";
	lv2.editeur = "omar";
	lv2.anneePub = "1998/03/21";
	lv2.nbrExmplr = 10;
	lv2.prix = 19.99;

	lv3.num = 3;
	lv3.titre = "hicham";
	lv3.auteur = "omar";
	lv3.editeur = "hicham";
	lv3.anneePub = "1998/03/21";
	lv3.nbrExmplr = 10;
	lv3.prix = 14.99;

	//declarer la taille de notre liste de livre
	lvr.livres_len = 3;

	//allouer espace pour notre liste de livre
	lvr.livres_val = malloc(3*sizeof(struct livre));

	// les initialiser car c livres c un tableau
	lvr.livres_val[0] = lv1;
	lvr.livres_val[1] = lv2;
	lvr.livres_val[2] = lv3;

	//return 1 dans le cas de success
	result = 1;
	return &result;
}

int *
ajouter_1_svc(livre *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
		Le probleme dans rpc que on a fréquenter c'est que on peut pas ajouter directement une case de livre
		dans notre liste des livres (livres), il faut allouer encore une fois une toute une liste pour
		la liste et ajouter la case
		par exemple 
		on avait 5 livre , taille 5
		il faut creer une nouvelle liste avec taille 6 et copier les 5 livres
		et à la fin ajouter le nouveau livre
	*/
	int length;

	//creer une liste temp pour copier les elements de l'ancienne liste
	livres temp;
	temp = lvr;

	//on a creer un livre temp pour copier les attributes de livre que on a recu (argp)
	livre lv1;

	//allouer pour les chaines de caracteres
	lv1.titre = (char*)malloc(30);
	lv1.auteur = (char*)malloc(30);
	lv1.editeur = (char*)malloc(30);
	lv1.anneePub = (char*)malloc(30);

	lv1.num = argp->num;

	/*
		on utilise strcpy pour copier les chaines de caractrer car il copier avec pointeur 
		mais pas par caractere , et c fonctionnell
	*/
	strcpy(lv1.titre , argp->titre);
	strcpy(lv1.auteur , argp->auteur);
	strcpy(lv1.editeur , argp->editeur);
	strcpy(lv1.anneePub , argp->anneePub);
	lv1.nbrExmplr = argp->nbrExmplr;
	lv1.prix = argp->prix;

	//length c'est la nouvelle taille (l'ancienne + 1)
	length = lvr.livres_len + 1;

	//initialiser la nouvelle taille pour notre liste lvr (liste globale)
	lvr.livres_len = length;

	//allouer espace
	lvr.livres_val = malloc(length * sizeof(struct livre));

	//bouvle for pour copier tout les elements de l'ancienne liste vers la nouvelle
	for(int i=0;i<length;i++)
	{
		lvr.livres_val[i] = temp.livres_val[i];
	}

	//ajouter dans la derniere position le nouveaux element
	lvr.livres_val[length-1] = lv1;

	//retourn 1 dans le cas de success
	result = 1;
	return &result;
}

int *
modifier_1_svc(livre *argp, struct svc_req *rqstp)
{
	static int  result;


	livre lv1;
	lv1.titre = (char*)malloc(30);
	lv1.auteur = (char*)malloc(30);
	lv1.editeur = (char*)malloc(30);
	lv1.anneePub = (char*)malloc(30);

	lv1.num = argp->num;
	strcpy(lv1.titre , argp->titre);
	strcpy(lv1.auteur , argp->auteur);
	strcpy(lv1.editeur , argp->editeur);
	strcpy(lv1.anneePub , argp->anneePub);
	lv1.nbrExmplr = argp->nbrExmplr;
	lv1.prix = argp->prix;


	//boucle for pour chercher element
	for(int i=0;i<lvr.livres_len;i++)
	{
		// si livre trouver
		if(lvr.livres_val[i].num == lv1.num)
		{
			// on remplit les nouvellles information
			lvr.livres_val[i].titre = lv1.titre;
			lvr.livres_val[i].auteur = lv1.auteur;
			lvr.livres_val[i].editeur = lv1.editeur;
			lvr.livres_val[i].anneePub = lv1.anneePub;
			lvr.livres_val[i].nbrExmplr = lv1.nbrExmplr;
            lvr.livres_val[i].prix = lv1.prix;
			
			//retourn 1 dans le cas de success
			result = 1;
		}
		else
		{
			//retourn 1 dans le cas de livre no trouver
			result = 0;
		}
	}

	return &result;
}

int *
supprimer_1_svc(int *argp, struct svc_req *rqstp)
{
	static int  result;

	//index c'est pour marquer la position de livre
	int index;
	for(int i=0;i<lvr.livres_len;i++)
	{
		if(lvr.livres_val[i].num == *argp)
		{
			//si le livre trouver on return son position
			index = i;
		}
		else
		{
			result = 0;
		}
	}

	/*
		on decale les positions des element i-1 a partir de la positions
		exemple
		[2,8,12,3,45,42], n=6
		on veut supprimer position 3
		on aura
		[2,8,12,45,42] et n=5
	*/
	for(int i = index ;i<lvr.livres_len-1;i++)
	{
		lvr.livres_val[i] = lvr.livres_val[i+1];
	}

	//recrir la nouvelle taille
    lvr.livres_len = lvr.livres_len - 1;

	// return 1 cas success
	result = 1;
	return &result;
}

livre *
consulter_1_svc(int *argp, struct svc_req *rqstp)
{
	static livre *result = NULL;
	for(int i=0;i<lvr.livres_len;i++)
	{

		// cas livre trouver
		if(lvr.livres_val[i].num == *argp)
		{
			// on alloue un espace pour livre et on le remplis
			result = malloc(sizeof(livre));
			result->titre = (char*)malloc(30);
			result->editeur = (char*)malloc(30);
			result->auteur = (char*)malloc(30);
			result->anneePub = (char*)malloc(30);
			result->num = lvr.livres_val[i].num;
			strcpy(result->titre , lvr.livres_val[i].titre);
			strcpy(result->editeur , lvr.livres_val[i].editeur);
			strcpy(result->auteur , lvr.livres_val[i].auteur);
			strcpy(result->anneePub , lvr.livres_val[i].anneePub);
			result->nbrExmplr = lvr.livres_val[i].nbrExmplr;
			result->prix = lvr.livres_val[i].prix;

			//ensuite retourner livre trouver
			return result;
		}
	}
	return result;
}

livres *
afficher_1_svc(void *argp, struct svc_req *rqstp)
{
	static livres  result;

	//returner direcement la list lvr
	result = lvr;

	return &result;
}

livres *
auteur_1_svc(char **argp, struct svc_req *rqstp)
{
	static livres  result,result_7;
	int num = 0,num2=0;
	for(int i=0;i<lvr.livres_len;i++)
	{
		// dans le cas auteur trouver
		if(strcmp(lvr.livres_val[i].auteur, *argp) == 0)
		{
			/*
				on calcule le nombre des livres de ce auteur , ensuite creer une liste de livre avec 
				la taille de numbre de livre trouver
			*/
			num++;
		}
	}
	//saisir la taille de numbre de livre trouver
	result_7.livres_len = num;

	//allouer espave pour le nombre de livre
	result_7.livres_val = malloc(num*sizeof(struct livre));


	//refaire le meme traitement quand on a chercher sur le nombre de livre trouver
	for(int i=0;i<lvr.livres_len;i++)
	{
		//mais cette fois c par copier les elements trouver dans la liste creer
		if(strcmp(lvr.livres_val[i].auteur, *argp) == 0)
		{
			result_7.livres_val[num2] = lvr.livres_val[i];
			
			//à chaque fois i++ pour la position suivante
			num2++;
		}
	}
	return &result_7;
}

float *
prix_1_svc(void *argp, struct svc_req *rqstp)
{
	static float  result;

	//boucler sur la liste et faire la summe des variables prix
	for(int i=0;i<lvr.livres_len;i++)
	{
		result +=lvr.livres_val[i].prix;
	}
	return &result;
}
