/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "livre.h"

//déclarer liste de livre globale
livres lvr;

int *
init_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	//remplire quelque livre pour initialisation

	livre lv1,lv2,lv3;

	lv1.num = 1;
	lv1.titre = "djabir";
	lv1.auteur = "djabir";
	lv1.editeur = "djabir";
	lv1.anneePub = "1998/04/01";
	lv1.nbrExmplr = 5;
	lv1.prix = 9.99;

	lv2.num = 2;
	lv2.titre = "omar";
	lv2.auteur = "omar";
	lv2.editeur = "omar";
	lv2.anneePub = "1998/03/21";
	lv2.nbrExmplr = 10;
	lv2.prix = 19.99;

	lv3.num = 3;
	lv3.titre = "zaza";
	lv3.auteur = "zaza";
	lv3.editeur = "zaza";
	lv3.anneePub = "1998/03/21";
	lv3.nbrExmplr = 10;
	lv3.prix = 14.99;

	//declarer la taille de notre liste de livre
	lvr.livres_len = 3;

	//allouer espace pour notre liste de livre
	lvr.livres_val = malloc(3*sizeof(struct livre));

	// Initialisation du tableau lvr qui est de type livre
	lvr.livres_val[0] = lv1;
	lvr.livres_val[1] = lv2;
	lvr.livres_val[2] = lv3;

	//return 1 dans le cas de succès
	result = 1;
	return &result;
}

int *
ajouter_1_svc(livre *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
		Le problème dans rpc qu'on a rencontré c'est qu'on ne peut pas ajouter directement une case de livre
		dans notre liste des livres (livres), il faut allouer encore une fois une toute nouvelle liste pour
		pouvoir ajouter la nouvelle case du livre
		par exemple 
		on avait 5 livre , donc la taille est égale à 5
		il faut créer une nouvelle liste avec taille égale à 6 et copier les 5 livres
		et à la fin ajouter le nouveau livre
	*/
	int length;

	//temp c'est liste de livre pour copier les anciens elements
	livres temp;
	temp = lvr;

	//on a creer un livre temp pour copier les attributes de livre recu (argp)
	livre lv1;

	//allouer pour les chaines de caracteres
	lv1.titre = (char*)malloc(30);
	lv1.auteur = (char*)malloc(30);
	lv1.editeur = (char*)malloc(30);
	lv1.anneePub = (char*)malloc(30);

	lv1.num = argp->num;

	/*
		on utilise strcpy pour copier les chaines de caractrer car il copie avec pointeur 
		mais pas par caractere , et c'est fonctionnelle
	*/
	strcpy(lv1.titre , argp->titre);
	strcpy(lv1.auteur , argp->auteur);
	strcpy(lv1.editeur , argp->editeur);
	strcpy(lv1.anneePub , argp->anneePub);
	lv1.nbrExmplr = argp->nbrExmplr;
	lv1.prix = argp->prix;

	//length c'est la nouvelle taille (l'ancienne + 1)
	length = lvr.livres_len + 1;

	//initialiser la nouvelle taille pour notre liste lvr (liste globale)
	lvr.livres_len = length;

	//allouer espace
	lvr.livres_val = malloc(length * sizeof(struct livre));

	//boucle for pour copier tout les elements de l'ancienne liste vers la nouvelle
	for(int i=0;i<length;i++)
	{
		lvr.livres_val[i] = temp.livres_val[i];
	}

	//ajouter dans la derniere position le nouveaux element
	lvr.livres_val[length-1] = lv1;

	//retourn 1 dans le cas de succes
	result = 1;
	return &result;
}

int *
modifier_1_svc(livre *argp, struct svc_req *rqstp)
{
	static int  result;


	livre lv1;
	lv1.titre = (char*)malloc(30);
	lv1.auteur = (char*)malloc(30);
	lv1.editeur = (char*)malloc(30);
	lv1.anneePub = (char*)malloc(30);

	lv1.num = argp->num;
	strcpy(lv1.titre , argp->titre);
	strcpy(lv1.auteur , argp->auteur);
	strcpy(lv1.editeur , argp->editeur);
	strcpy(lv1.anneePub , argp->anneePub);
	lv1.nbrExmplr = argp->nbrExmplr;
	lv1.prix = argp->prix;


	//boucle for pour chercher element
	for(int i=0;i<lvr.livres_len;i++)
	{
		// si le livre a été trouver
		if(lvr.livres_val[i].num == lv1.num)
		{
			// on remplit les nouvellles information
			lvr.livres_val[i].titre = lv1.titre;
			lvr.livres_val[i].auteur = lv1.auteur;
			lvr.livres_val[i].editeur = lv1.editeur;
			lvr.livres_val[i].anneePub = lv1.anneePub;
			lvr.livres_val[i].nbrExmplr = lv1.nbrExmplr;
            lvr.livres_val[i].prix = lv1.prix;
			
			//retourn 1 dans le cas de succes
			result = 1;
		}
		else
		{
			//retourn 1 dans le cas de livre non trouver
			result = 0;
		}
	}

	return &result;
}

int *
supprimer_1_svc(int *argp, struct svc_req *rqstp)
{
	static int  result;

	int position;
	for(int i=0;i<lvr.livres_len;i++)
	{
		if(lvr.livres_val[i].num == *argp)
		{
			position = i;
		}
		else
		{
			position = 0;
		}
	}
	for(int i = position ;i<lvr.livres_len-1;i++)
	{
		lvr.livres_val[i] = lvr.livres_val[i+1];
	}

	//supprimer une case car on a supprimer un livre
    lvr.livres_len = lvr.livres_len - 1;

	result = 1;
	return &result;
}

livre *
consulter_1_svc(int *argp, struct svc_req *rqstp)
{
	static livre *result = NULL;
	for(int i=0;i<lvr.livres_len;i++)
	{

		// cas livre trouver
		if(lvr.livres_val[i].num == *argp)
		{
			// on alloue un espace pour livre et on le remplis
			result = malloc(sizeof(livre));
			result->titre = (char*)malloc(30);
			result->editeur = (char*)malloc(30);
			result->auteur = (char*)malloc(30);
			result->anneePub = (char*)malloc(30);
			result->num = lvr.livres_val[i].num;
			strcpy(result->titre , lvr.livres_val[i].titre);
			strcpy(result->editeur , lvr.livres_val[i].editeur);
			strcpy(result->auteur , lvr.livres_val[i].auteur);
			strcpy(result->anneePub , lvr.livres_val[i].anneePub);
			result->nbrExmplr = lvr.livres_val[i].nbrExmplr;
			result->prix = lvr.livres_val[i].prix;

			//ensuite retourner le livre trouvé
			return result;
		}
	}
	return result;
}

livres *
afficher_1_svc(void *argp, struct svc_req *rqstp)
{
	static livres  result;

	//retourne directement la liste lvr
	result = lvr;

	return &result;
}

livres *
auteur_1_svc(char **argp, struct svc_req *rqstp)
{
	static livres  result,result_7;
	int num = 0,num2=0;
	for(int i=0;i<lvr.livres_len;i++)
	{
		if(strcmp(lvr.livres_val[i].auteur, *argp) == 0)
		{
			num++;
		}
	}
	//saisir la taille de nombre de livre trouver
	result_7.livres_len = num;

	//allouer un espace pour le nombre de livre
	result_7.livres_val = malloc(num*sizeof(struct livre));


	//refaire le meme traitement quand on a chercher sur le nombre de livre trouver
	for(int i=0;i<lvr.livres_len;i++)
	{
		//mais cette fois c'est par copier les elements trouver dans la liste creer
		if(strcmp(lvr.livres_val[i].auteur, *argp) == 0)
		{
			result_7.livres_val[num2] = lvr.livres_val[i];
			
			//à chaque fois i++ pour la position suivante
			num2++;
		}
	}
	return &result_7;
}

float *
prix_1_svc(void *argp, struct svc_req *rqstp)
{
	static float  result;

	//boucler sur la liste et faire la somme des variables prix
	for(int i=0;i<lvr.livres_len;i++)
	{
		result +=lvr.livres_val[i].prix;
	}
	return &result;
}
